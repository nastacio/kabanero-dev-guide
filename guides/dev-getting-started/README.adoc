---
permalink: /guides/dev-getting-started/
---
:page-layout: guide
:page-duration: 75 minutes
:page-description: Workshop content for developers and solution architects getting started with Kabanero
:page-title: Getting Started With Kabanero Development
:page-related-guides: ['otheguidename', 'otheguidename2']
:linkattrs:

= Kabanero Developer Experience - Getting Started

////
Copyright 2019 IBM Corporation and others.

Licensed undser the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http:www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////

:kabanero-collection: v0.2.0-beta1

== What is Kabanero

Kabanero is an open source project focused on bringing together key
foundational open source technologies into a framework for developing
and deploying modern cloud-native applications. The Kabanero developer
experience leverages the Appsody and Eclipse Codewind open source
projects enabling developers to use project 'templates' to rapidly
create new cloud-native applications, develop and build them in a
curated container 'stack' environment and deploy them to
Knative/Kubernetes all without the need for container or Kubernetes
skills.

== What you will learn

This tutorial will give you an introduction to the Kabanero developer
experience. You’ll create and deploy a Node.js cloud-native application, 
however, Kabanero provides a number of stacks,
including Java and Spring Boot, and is extensible so others can easily
be added. For more information, see https://appsody.dev/[Appsody.dev].

At the end of this tutorial, you should have a good understanding of the
Kabanero developer experience through the use of Appsody and Eclipse
Codewind. You’ll know how to create a new application, develop and
deploy it to Knative and have an appreciation for how Kabanero does all
the heavy-lifting helping you focus on the task of writing the code.


== Pre-requisites

You need to install the following pre-requisites to
complete this tutorial:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
- https://code.visualstudio.com/[Visual Studio Code]
- https://docs.docker.com/docker-for-mac/[Docker Desktop]
- https://www.python.org/downloads/release/python-374/[Python 3] and https://vgkits.org/blog/pip3-macos-howto/[Pip3]. These dependencies are related to the scenarios for Kabanero solution architects and not required for regular application development. This workshop was tested with version 3.6.8 of python3.
--

[.tab_content.windows_section]
--
- Windows 10 Professional or Windows 10 Enterprise.
- https://code.visualstudio.com/[Visual Studio Code]
- https://docs.docker.com/docker-for-windows/[Docker Desktop]
- Follow the instructions in the
link:docker-windows-aad[Special notes about Docker Desktop on Windows
10] to ensure your Docker installation can successfully write content to
volumes mounted into containers.
- https://www.cygwin.com/[Cygwin]. Make sure to include the
non-default `python3` and `python36-setup` packages, then issue 
`+easy_install-3.6 pip+` to get `+pip+` installed. These dependencies are 
related to the scenarios for Kabanero solution architects and not required for 
regular application development. This workshop was tested with 
version 3.6.8 of python3.
(https://github.com/appsody/appsody/issues/45[github issue #54] will
soon remove the dependencies on cygwin and python packages). 
- Ensure
your Cygwin home directory *matches your Windows home directory*, as
described in
https://ryanharrison.co.uk/2015/12/01/cygwin-change-home-directory.html[this
blog entry]. 
- The workshop content *has not* been validated against the
https://docs.microsoft.com/en-us/windows/wsl[Windows Subsystem for Linux
(WSL)].
--

=== Enable Kubernetes 

Docker Desktop contains a standalone Kubernetes cluster for development purposes.
You will need to enable Kubernetes as this is disabled by default in Docker Desktop. 

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
Open the "Preferences" dialog, switch to the "Kubernetes" tab, and select the "Enable Kubernetes" 
option, as described in the 
https://docs.docker.com/docker-for-mac/#kubernetes[Docker Destop for Mac] page.

[.tab_content.windows_section]
Open the "Settings" dialog, switch to the "Kubernetes" tab, and select the "Enable Kubernetes" 
option, as described in the 
https://docs.docker.com/docker-for-windows/#kubernetes[Docker Destop for Windows] page.


== Visual Studio Code Kabanero Setup
//
=== Installing the Codewind Extension for Visual Studio Code

https://www.eclipse.org/codewind/[Eclipse Codewind] provides a set of extensions to IDEs for doing
cloud-native application development. They enable a full developer/debug
cycle with an incremental build where all the code is built and run
inside a container. This means that the likelihood of issues due to
different development, build and production environments is vastly
reduced.

Although Codewind is an Eclipse project, it’s not limited to the Eclipse
IDE and in this tutorial, you will use Codewind inside Visual Studio
Code.

Codewind requires Docker, so before you begin, ensure your Docker
install is complete and running.

To install the "Codewind Extension" for "Visual Studio Code", you have
two options.

. Install using the *Install* button on
https://marketplace.visualstudio.com/items?itemName=IBM.codewind[this
page].
. Manually launch Visual Studio Code, navigate to the *Extensions* view,
search for *Codewind*, and install the extension from here.

=== Installing the Appsody CLI

Depending on your operating system, the installation process for the
*Appsody CLI* will differ. To correctly install *Appsody* for your
operating system, view the following
https://appsody.dev/docs/getting-started/installation[link].

Verify that the CLI tool is installed correctly by executing the
following into your terminal:

[source, role='command']
```
appsody version
```

=== Sharing the Appsody Configuration between the CLI and Visual Studio Code - Optional

While this is optional, it is recommended. Rather than having *Appsody
CLI* projects stored separately to those you may create in an editor
such as *Visual Studio Code* or *Eclipse*, updating the *Appsody*
configuration file will enable you to work on your projects across both
the CLI and editor.

To share the Appsody configuration, follow the instructions at
https://github.com/eclipse/codewind-appsody-extension#optional-using-the-same-appsody-configuration-between-local-cli-and-codewind[this
repository].

== Pre-requisite checks and caching of large images

This step will ensure your environment has all the prerequisites
installed and running.

In addition to checking prerequisites, this step will also cache large
images into your local system. The cached content will save you valuable
time at the beginning of the workshop.

(Windows users should execute it from a Cygwin shell) :

[source, role='command']
```
curl -sL https://github.com/gcharters/kabanero-dev-getting-started/releases/download/0.0.2/workshop-setup.sh | bash
```

== Developing Cloud-native applications - Appsody

=== Getting to know Appsody

We’re going to start by trying out the developer experience Appsody
provides and then we’ll move on to use Eclipse Codewind.

Let’s take a look at what Appsody provides in terms of capabilities. In
a command prompt, type:

[source, role='command']
```
appsody
```

You should see output similar to the following:

[source, role="no_copy"]
----
The Appsody command-line tool (CLI) enables the rapid development of cloud native applications.

Complete documentation is available at https://appsody.dev

Usage:
  appsody [command]

Available Commands:
  build       Locally build a docker image of your appsody project
  completion  Generates bash tab completions
  debug       Run the local Appsody environment in debug mode
  deploy      Build and deploy your Appsody project to your Kubernetes cluster
  extract     Extract the stack and your Appsody project to a local directory
  help        Help about any command
  init        Initialize an Appsody project with a stack and template app
  list        List the Appsody stacks available to init
  operator    Install or uninstall the Appsody operator from your Kubernetes cluster.
  repo        Manage your Appsody repositories
  run         Run the local Appsody environment for your project
  stop        Stops the local Appsody docker container for your project
  test        Test your project in the local Appsody environment
  version     Show Appsody CLI version

Flags:
      --config string   config file (default is $HOME/.appsody/.appsody.yaml)
      --dryrun          Turns on dry run mode
  -h, --help            help for appsody
  -v, --verbose         Turns on debug output and logging to a file in $HOME/.appsody/logs

Use "appsody [command] --help" for more information about a command.
----

The Appsody CLI has a number of *Commands*. The majority of these
commands are for working with stacks: build, debug, run stop, test, and
extract, list.

Let’s take a look at what stacks we have available by entering:

[source, role='command']
```
appsody list
```

This command lists the available stacks and you should see something
like:

[source, role="no_copy"]
----
REPO                    ID                          VERSION     TEMPLATES   DESCRIPTION                                              
appsodyhub              java-microprofile           0.2.11      *default    Eclipse MicroProfile using OpenJ9 and Maven              
appsodyhub              java-spring-boot2           0.3.8       *default    Spring Boot using OpenJ9 and Maven                       
appsodyhub              nodejs                      0.2.5       *simple     Runtime for Node.js applications                         
appsodyhub              nodejs-express              0.2.5       *simple     Express web framework for Node.js                        
appsodyhub              nodejs-loopback             0.1.3       *scaffold   LoopBack API framework for Node.js                       
appsodyhub              swift                       0.1.4       *simple     Runtime for Swift applications
----

You’ll see that with the stacks available, we can develop new
cloud-native applications using Java, Node.js or Swift, with a number of
different, popular frameworks.

You can also register new repositories containing stacks created from
the ground up or as forks of the default stacks shipped with Appsody

To illustrate that point, we can register the repository for 
Kabanero collections, using the following command:

[source, role='command']
```
appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml

appsody repo list
```

You should see an output similar to this:

[source, role="no_copy"]
----
NAME       	URL                                                                                          
*appsodyhub	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml              
kabanero   	https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml
----

`+Appsodyhub+` is the location where the appsody project releases its
stacks. The `+*+` indicates that this is the default repository. We can
instruct appsody to set the new kabanero repository as the default repository:

....
$ appsody repo set-default kabanero
Your default repository is now set to kabanero

$ appsody repo list

NAME      	URL                                                                                          
*kabanero 	https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml
appsodyhub	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml       
....


We’re going to use a custom stack created for this workshop. Anybody can
write a stack or customize a stack for use by others. Maybe you want to
add support for another language or framework, or perhaps your company
has additional governance requirements that you want to add into an
existing stack. We’ll go into more details on stack development later,
but for now, let’s add in the stack we’ll use in this part of the
workshop.

The preparation steps for the workshop cloned the Kabanero collections
repository to your local workstation, so we can make local modifications and 
use `appsody stack` commands to build the custom versions of collections.

The https://github.com/kabanero-io/collections[Kabanero Collections repository] has the 
complete instructions for releasing the custom collections for usage within a larger 
organization.

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
cd ${workshop_dir}/collections/incubator
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
cd %workshop_dir%\collections\incubator
```
--

If you list the contents of that directory, you should see something like this:

[source, role="no_copy"]
----
common
java-microprofile
java-spring-boot2
nodejs
nodejs-express
nodejs-loopback
----

This is the list of Kabanero collections, which each directory containing the folder
structure matching the https://appsody.dev/docs/stacks/stack-structure[structure of an Appsody stack].
The stack we want to use is in the `+nodejs-express+` repository.

[source, role='command']
```
cd nodejs-express
appsody stack package
```


You will notice the presence of the new dev-local repository:

[source, role='command']
```
appsody repo list
```

You should see:

[source, role="no_copy"]
----
NAME       	URL                                                                                          
*appsodyhub	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml              
dev-local  	file:///Users/nastacio/.appsody/stacks/dev.local/index-dev-local.yaml                        
kabanero   	https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml
----

Let’s see what stacks we now have available:

[source, role='command']
```
appsody list
```

You should now see an entry for a stack called
`+nodejs-express+` from the `+dev-local+` repository.

[source, role="no_copy"]
--
REPO       	ID               	VERSION  	TEMPLATES        	DESCRIPTION                                              
*appsodyhub	java-microprofile	0.2.17   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
*appsodyhub	java-spring-boot2	0.3.14   	*default, kotlin 	Spring Boot using OpenJ9 and Maven                       
*appsodyhub	nodejs           	0.2.5    	*simple          	Runtime for Node.js applications                         
*appsodyhub	nodejs-express   	0.2.7    	scaffold, *simple	Express web framework for Node.js                        
*appsodyhub	nodejs-loopback  	0.1.5    	*scaffold        	LoopBack 4 API Framework for Node.js                     
*appsodyhub	python-flask     	0.1.4    	*simple          	Flask web Framework for Python                           
*appsodyhub	swift            	0.1.4    	*simple          	Runtime for Swift applications                           
dev-local  	nodejs-express   	0.2.6    	*simple, skaffold	Express web framework for Node.js                        
kabanero   	java-microprofile	0.2.14   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
kabanero   	java-spring-boot2	0.3.13   	*default, kotlin 	Spring Boot using OpenJ9 and Maven                       
kabanero   	nodejs           	0.2.5    	*simple          	Runtime for Node.js applications                         
kabanero   	nodejs-express   	0.2.6    	*simple, skaffold	Express web framework for Node.js                        
kabanero   	nodejs-loopback  	0.1.4    	*scaffold        	LoopBack 4 API Framework for Node.js
--

We’re now ready to start creating applications using this local Appsody stack.

=== Creating a new Project with Appsody

Make a directory to contain your project:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
mkdir -p ~/workspace/kabanero-workshop/nodejs
cd ~/workspace/kabanero-workshop/nodejs
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
mkdir %USERPROFILE%\workspace\kabanero-workshop\nodejs
cd %USERPROFILE%\workspace\kabanero-workshop\nodejs
```
--

Create the new project. This project will be using the Node.JS Express framework.

[source, role='command']
appsody init dev-local/nodejs-express


When the build completes, you should see something like:

[source, role="no_copy"]
...
[InitScript] [INFO] ------------------------------------------------------------------------
[InitScript] [INFO] BUILD SUCCESS
[InitScript] [INFO] ------------------------------------------------------------------------
[InitScript] [INFO] Total time: 0.800 s
[InitScript] [INFO] Finished at: 2019-09-02T15:52:41+01:00
[InitScript] [INFO] ------------------------------------------------------------------------
Successfully initialized Appsody project


Open up the project in VS Code.

[source, role='command']
code .

Special note for compiled languages, such as Java: To experience the incremental 
update during development you will need an IDE that automatically compiles the source files each time
they are saved. For instance, VS Code (with the Red Hat
`+Language Support for Java+`), Eclipse and IntelliJ IDEA are all known
to work.


Expand the project `+src+` and you should see a structure and code like
this:

This project template was designed with simplicity in mind, containing only
a skeleton Node.JS application and Appsody control files:

[source, role="no_copy"]
```
./test/test.js
./.gitignore
./package-lock.json
./package.json
./.appsody-config.yaml
./.vscode/launch.json
./.vscode/tasks.json
./app.js
```


=== Live coding with Appsody

Let’s start the new application ready to make some edits. Enter the
following command:

[source, role='command']
appsody run

The run command for this stack has been set up to run the application 
with `node` and use hot code updates to reflect code changes made
to the source tree.

After a while you should see output similar to the following:

[source, role="no_copy"]
Running development environment...
Pulling docker image dev.local/nodejs-express:SNAPSHOT
Running command: docker pull dev.local/nodejs-express:SNAPSHOT
Error response from daemon: Get https://dev.local/v2/: Service Unavailable
[Warning] Docker image pull failed: exit status 1
Using local cache for image dev.local/nodejs-express:SNAPSHOT
Running docker command: docker run --rm -p 3000:3000 -p 8080:8080 -p 9229:9229 --name node-js-dev -v /Users/nastacio/workspace/kabanero-workshop/nodejs/:/project/user-app -v node-js-deps:/project/user-app/node_modules -v /Users/nastacio/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller dev.local/nodejs-express:SNAPSHOT --mode=run
[Container] Running APPSODY_PREP command: npm install --prefix user-app
added 170 packages from 578 contributors and audited 295 packages in 3.639s
[Container] found 0 vulnerabilities
[Container] 
Running command:  npm start
[Container] Running command:  npm start
[Container] Wait received error on APPSODY_RUN/DEBUG/TEST signal: interrupt
[Container] 
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container] [Tue Oct  8 15:04:22 2019] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910032155 (Agent Core 4.0.5)
[Container] [Tue Oct  8 15:04:23 2019] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000
[Container] Running command:  npm start
[Container] [Warning] Wait Received error starting process of type APPSODY_RUN/DEBUG/TEST_ON_CHANGE while running command: npm start error received was: signal: interrupt
[Container] 
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container] [Tue Oct  8 15:04:23 2019] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910032155 (Agent Core 4.0.5)
[Container] [Tue Oct  8 15:04:24 2019] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000


Let’s now make a code change. The Node.js Express stack can dynamically 
update the running application without needing a restart.

First, navigate to the REST application endpoint to confirm that there
are no esources available. Open the following link in your
browser:

http://localhost:3000/resource

You should see an `+Not Found+` response.

Modify the app.js source file to include the extra "/resource" REST path:

[source,nodejs]
----
const app = require('express')()

app.get('/', (req, res) => {
  res.send("Hello from Appsody!");
});

app.get('/resource', (req, res) => {
  res.send("Resource from Appsody!");
});

module.exports.app = app;
----

You should see that upon saving the file the source code change is detected 
and the application updated:

[source, role="no_copy"]
[Container] Running command:  npm start
[Container] [Warning] Wait Received error starting process of type APPSODY_RUN/DEBUG/TEST_ON_CHANGE while running command: npm start error received was: signal: interrupt
[Container] 
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container] [Tue Oct  8 15:38:53 2019] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910032155 (Agent Core 4.0.5)
[Container] [Tue Oct  8 15:38:53 2019] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000


Now if you browse http://localhost:3000/resource, you should see the message 
`+Resource from Appsody!+` instead of the original `+Not Found+` message 

Try changing the message in `+app.js+` saving and
refreshing the page. You’ll see it only takes a few seconds for the
change to take effect.

When you’re done, type `+Ctrl-C+` to end the appsody run.

=== Deploying to Kubernetes

You’ve finished writing your code and want to deploy to Kubernetes. The
Kabanero project integrates Tekton as a CI/CD pipeline for deploying to
Kubernetes (including Knative and Istio). This enables you to commit
your changes to a git repo and have a Tekton pipeline build and
potentially deploy the project.

A full Kabanero set-up was considered too much for this workshop, so
here we’re going to make use of a nice little feature from Appsody,
`+appsody deploy+`. In the terminal in the root of your project, type:

[source, role='command']
appsody deploy

At the end of the deploy, you should see an output like this:

[source, role="no_copy"]
Built docker image dev.local/nodejs
Using applicationImage of: dev.local/nodejs
Attempting to apply resource in Kubernetes ...
Running command: kubectl apply -f app-deploy.yaml --namespace default
Deployment succeeded.
Appsody Deployment name is: nodejs
Running command: kubectl get rt nodejs -o jsonpath="{.status.url}" --namespace default
Attempting to get resource from Kubernetes ...
Running command: kubectl get route nodejs -o jsonpath={.status.ingress[0].host} --namespace default
Attempting to get resource from Kubernetes ...
Running command: kubectl get svc nodejs -o jsonpath=http://{.status.loadBalancer.ingress[0].hostname}:{.spec.ports[0].nodePort} --namespace default
Deployed project running at http://localhost:30062

The very last line tells you where the application is available. Let’s
call the resource by opening this endpoint in the browser:

http://localhost:30062/resource

You should now see the response from your JAX-RS resource.

Let’s take a look at the deployment. Enter:

[source, role='command']
kubectl get all


You should see an output similar to this:

[source, role="no_copy"]
--
NAME                                    READY   STATUS    RESTARTS   AGE
pod/appsody-operator-6bbddbd455-r65vp   1/1     Running   0          6m57s
pod/nodejs-7d84ddc98d-r7bnj             1/1     Running   0          44s


NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
service/appsody-operator   ClusterIP   10.100.219.241   <none>        8383/TCP         6m51s
service/kubernetes         ClusterIP   10.96.0.1        <none>        443/TCP          9m13s
service/nodejs             NodePort    10.110.138.128   <none>        3000:30062/TCP   44s


NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/appsody-operator   1/1     1            1           6m57s
deployment.apps/nodejs             1/1     1            1           44s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/appsody-operator-6bbddbd455   1         1         1       6m57s
replicaset.apps/nodejs-7d84ddc98d             1         1         1       44s
--

The entries with `+nodejs+` are your applications. The
`+appsody-operator+` are those used by Appsody to perform the
deployment.

It’s worth noting at this point that this deployment was achieved
without us having to write, or understand, a Dockerfile or Kubernetes
deployment yaml.

Now list the files in your project directory. You should see something
like this:

[source, role="no_copy"]
....
-rw-r--r--  1 nastacio  staff    628 Oct  8 14:05 app-deploy.yaml
-rw-r--r--  1 nastacio  staff    130 Oct  8 14:02 app.js
-rw-r--r--  1 nastacio  staff  51421 Oct  8 14:02 package-lock.json
-rw-r--r--  1 nastacio  staff    455 Oct  8 14:02 package.json
drwxr-xr-x  3 nastacio  staff     96 Oct  8 14:02 test
....

The `+app-deploy.yaml+` is generated from the stack and used to deploy
to Kubernetes. If you look inside the file, you’ll see entries for
`+liveness+` and `+readiness+` probes, metrics, and the service port.

Check out the `+liveness+` and `+readiness+` endpoints by pointing your
browser at the following URLs, remembering to replace the port numbers with
the port numbers from the output of the `appsody deploy` command:

* http://localhost:30062/live
* http://localhost:30062/ready

You should see something like:

[source,json]
----
// http://localhost:30062/ready

{
    "status":"UP",
    "checks":[]
}
----

These endpoints are provided by the stack health checks generated
by the project starter.

Finally, let’s undeploy the application by entering:

[source, role='command']
```
appsody deploy delete
```


You should see an output something like this:

[source, role="no_copy"]
----
....
Deleting deployment using deployment manifest app-deploy.yaml
Attempting to delete resource from Kubernetes...
Running command: kubectl delete -f app-deploy.yaml --namespace default
Deployment deleted
....
----

Check that everything was undeployed using:

[source, role='command']
```
kubectl get all
```

You should see output similar to this:

[source, role="no_copy"]
....
NAME                                    READY   STATUS    RESTARTS   AGE
pod/appsody-operator-6bbddbd455-r65vp   1/1     Running   0          13m


NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/appsody-operator   ClusterIP   10.100.219.241   <none>        8383/TCP   13m
service/kubernetes         ClusterIP   10.96.0.1        <none>        443/TCP    15m


NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/appsody-operator   1/1     1            1           13m

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/appsody-operator-6bbddbd455   1         1         1       13m
....

What if you decide you want to see the Container and Kubernetes
configuration that Appsody is using, or you want to take your project
elsewhere? You can do this as follows. Enter:

[source, role='command']
```
appsody extract --target-dir tmp-extract
```

You should see output similar to:

[source, role="no_copy"]
....
Extracting project from development environment
Pulling docker image dev.local/nodejs-express:SNAPSHOT
Running command: docker pull dev.local/nodejs-express:SNAPSHOT
Error response from daemon: Get https://dev.local/v2/: Service Unavailable
[Warning] Docker image pull failed: exit status 1
Using local cache for image dev.local/nodejs-express:SNAPSHOT
[Warning] The stack image does not contain APPSODY_PROJECT_DIR. Using /project
Running command: docker create --name nodejs-extract -v /Users/nastacio/workspace/kabanero-workshop/nodejs/:/project/user-app dev.local/nodejs-express:SNAPSHOT
Running command: docker cp nodejs-extract:/project /Users/nastacio/.appsody/extract/nodejs
Running command: docker rm nodejs-extract -f
Project extracted to /Users/nastacio/workspace/kabanero-workshop/nodejs/tmp-extract
....

Let’s take a look at the extracted project:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
cd ~/workspace/kabanero-workshop/nodejs/tmp-extract
ls -al
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
cd %USERPROFILE%\workspace\kabanero-workshop\nodejs\tmp-extract
dir
```
--

You should see output similar to the following:

[source, role="no_copy"]
....
drwxr-xr-x   10 nastacio  staff    320 Oct  3 17:55 .
drwxr-xr-x   11 nastacio  staff    352 Oct  8 14:15 ..
-rw-r--r--    1 nastacio  staff     48 Oct  3 14:41 .dockerignore
-rw-r--r--    1 nastacio  staff    878 Oct  3 14:41 Dockerfile
drwxr-xr-x  274 nastacio  staff   8768 Oct  3 17:55 node_modules
-rw-r--r--    1 nastacio  staff  92237 Oct  3 17:55 package-lock.json
-rw-r--r--    1 nastacio  staff    659 Oct  3 14:41 package.json
-rw-r--r--    1 nastacio  staff   1462 Oct  3 14:41 server.js
drwxr-xr-x    3 nastacio  staff     96 Oct  3 14:41 test
drwxr-xr-x   10 nastacio  staff    320 Oct  8 14:04 user-app
....

These are the files for the project, including those provided by the
stack. For example, the `+package.json+` has the core application definition 
for your application, and the `+Dockerfile+` is the one used to build and package
the application. The `+user-app+` is the Node.js project for your
application.

That’s it for the Appsody part of the workshop. You’ve seen how Appsody
`+stacks+` and `+templates+` make it easy to get started with a new
project with a curated and consistent dev and production environment.
You’ve also seen how Appsody makes it really easy to build
production-ready containers and deploy them to a Kubernetes environment.
Let’s now take a look at Codewind.

== Developing Cloud-native applications - Codewind

=== Using a Custom Appsody Stack from Codewind

By default, Codewind has integration for the Kabanero stacks, which are 
based on the stacks released by the Appsody project. 

It is worth looking at the Codewind configuration to understand how to
eventually include references to custom stacks, such as the one we will 
be building in this workshop.

In order to include additional stacks to the list of stacks available
inside Codewind, you can add them through the template sources panel.
Right-click the Projects icon in the Codewind section of the Visual Code
Studio Explorer and select "Manage Template Sources":

Make sure you have "Kabanero Collections" enabled and "Appsody Stacks"
disabled, otherwise you may see stacks with the same name and descriptions
in the list of stack options when creating a new Codewind project.

.Codewind template sources 
image::/img/guide/kab-workshop-codewind-template-sources.png[link="/img/guide/kab-workshop-codewind-template-sources.png" alt="Codewind template sources"]

You’re now ready to use the Kabanero collections from within Codewind.

=== Creating a new Codewind Project

We’ve seen how the Appsody CLI helps create, build and deploy projects
based on stacks and templates. Let’s now see how Codewind augments the
Appsody experience with tools for cloud-native development.

We’re going to start by creating a new Node.js project. These first
steps are the same for all the supported project types.

To get started with writing the project, hover over the *Projects* entry
underneath *Codewind* in *Visual Studio Code* and press the *+* icon to
create a new project.

.New Codewind project 
image::/img/guide/kab-workshop-new-project.png[link="/img/guide/kab-workshop-new-project.png" alt="New Codewind project"]


You should see a list of project types you can create. Select the
`+Kabanero Collections+` group, then select `Appsody Node.js Express simple template`.

.New Node.js Express project 
image::/img/guide/kab-workshop-codewind-new-nodejs.png[link="/img/guide/kab-workshop-codewind-new-nodejs.png" alt="New Node.js Express project"]

In the next field give the project a name, e.g `+kabanero-node-project+`

Press `+Enter+` to create the project.

The project has been generated and will now be building. To see the
progress, expand `+Codewind+` -> `+Projects+` and right click the menu
options `+Show all logs+`:

After a little while you should see the following log message:

[source, role="no_copy"]
....
Removing intermediate container 13648583c48c
 ---> 6f9d1a63dd11
Step 10/10 : CMD ["npm", "start"]
 ---> Running in 57255d64995d
Removing intermediate container 57255d64995d
 ---> bab327cf0931
Successfully built bab327cf0931
Successfully tagged cw-kabaneronodeproject-55db2350-ea0d-11e9-b965-597841276b82:latest
....

And the state for the project should change to `+Running+`:

.Node.js Express project running
image::/img/guide/kab-workshop-codewind-nodejs-running.png[link="/img/guide/kab-workshop-codewind-nodejs-running.png" alt="Node.js Express project running"]

The generated project contains all the boiler-plate code to get started
with developing a Node.js Express application. This is the exact same
code we saw generated for the new Appsody project.

To access the application endpoint in a browser, select the *Open App*
icon next to the project’s name, or right-click on the project and
select the `+Open App+` menu option. This opens up the application in
the running container showing a welcome page for the project.

.Launch Node.js Express application
image::/img/guide/kab-workshop-codewind-launch-nodejs.png[link="/img/guide/kab-workshop-codewind-launch-nodejs.png" alt="Launch Node.js Express application"]

Let’s take a look at the code. In the *Visual Studio Code Explorer* you should see
an entry with your Codewind project name. If you don’t find
it, right-click on the project and choose `+Add Folder to Workspace+`.
In the workspace view, expand the project and the sub-folders to show
all the files created from the Appsody template (Note, the template is
not intended to be a sample as most people would end up having to delete
the code each time, it aims to provide the starter code, server
configuration and build to which you can add your code).

The main source file is *app.js*, which serves the root path of your REST API.

Let’s modify that file to add the "/resource" REST endpoint to your application:

[source,node]
----
const app = require('express')()

app.get('/', (req, res) => {
  res.send("Hello from Appsody!");
});
 
app.get('/resource', (req, res) => {
  res.send("Resource from Appsody!");
});

module.exports.app = app;
----

Any changes you make to your code will automatically be 
re-deployed by *Codewind*, and viewed in your browser.

If you still have the logs `+OUTPUT+` tab open you will see that the
code is compiled and the application restarted. You should see messages
like:

[source, role="no_copy"]
....
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container]  Wed Oct  9 01:44:20 2019  com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910041526 (Agent Core 4.0.5)
[Container]  Wed Oct  9 01:44:21 2019  com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000
....

Point your browser at the new resource (note, `+<port>+` is the port
number you saw when you first opened the application):

....
http://127.0.0.1:<port>/resource
....

You should see the following response:

[source, role="no_copy"]
....
Resource from Appsody!
....

=== Looking Inside the Container

During development you may need to look inside the container to see
what’s deployed and configured. Codwind makes this easy. Select the
`+Open Container Shell+` option:

.Open Container Shell
image::/img/guide/kab-workshop-codewind-shell.png[link="/img/guide/kab-workshop-codewind-shell.png" alt="Open Container Shell"]

The following shows the files and location where the shell opens inside
the container. This is the root of your project.

.Listing application files from container shell
image::/img/guide/kab-workshop-codewind-shell-commands.png[link="/img/guide/kab-workshop-codewind-shell-commands.png" alt="Listing application files from container shell"]

You can navigate around the various directories for the application
and its dependencies.

=== Viewing Application Metrics

Let’s take a look at the application metrics built in to Codewind.
Right-click on the application and select `+Open Application Monitor+`:

This should open a page in your browser showing the metrics
dashboard with various system resource and response time data.
To make it more interesting,
hit the REST endpoint a few times to see the effects. You should end up
with a dashboard looking something like:

.Codewind Application Metrics Dashboard
image::/img/guide/kab-workshop-codewind-performance.png[link="/img/guide/kab-workshop-codewind-performance.png" alt="Codewind Application Metrics Dashboard"]

The dashboard helps you understand the runtime characteristics of your
service. Keep the dashboard open for now.

=== Running Load Tests

Let’s now take a look at the load testing support of Codewind.
Right-click on the application and select
`+Open Performance Dashboard+`:

In a browser tab you should see the Codewind performance dashboard.
Click on `+Edit load run settings+` and change the path to point to the
REST service endpoint `+/resource+` and click `+Save+` to save
the settings. Click `+Run Load Test+`, in the dialog, give the test a
name `+Test 1+` and choose `+Run+`:

.Edit load run settings
image::/img/guide/kab-workshop-codewind-edit-load-test.png[link="/img/guide/kab-workshop-codewind-edit-load-test.png" alt="Edit load run settings"]

When the tests are complete you should see results similar to the
following (you may need to click refresh in the browser). Click the
check-boxes for `+Response+`, `+Hits+`, `+CPU+` and `+Memory+`.

.Load test results
image::/img/guide/kab-workshop-codewind-performance-test.png[link="/img/guide/kab-workshop-codewind-performance-test.png" alt="Load test results"]

To see the effect of the load test on the service, take a look at the
metrics dashboard you opened earlier. You should see spikes in the
various measures.

Let’s do some development and degrade the performance of the services.
Update the `+GET+` method with the following and save the file. As
before, the application will be automatically updated:

[source,java]
----
app.get('/resource', (req, res) => {
  setTimeout(function() {
    res.send("Resource from Appsody!");
  }, 3000);  
});
----

In the performance dashboard, click `+Run Load Test+`, give the test
another name, e.g. `+Test 2+`, and click `+Run+`. When the tests
complete, you should see results similar to the following:

We can see clearly from the chart that the response time has increased.
Revisit the metrics dashboard and we can also see the response time
increase:

=== Deploy the Project to Knative or Kubernetes via the CLI

The project you created is a normal Appsody project and so can be worked
with using the Appsody CLI. As per the Appsody part of this workshop,
deploy the application to Kubernetes using:

Linux users:

....
cd ~/codewind-workspace/kabanero-mp-project
appsody deploy
....

Windows users:

....
cd c:\codewind-workspace\kabanero-mp-project
appsody deploy
....

If this was successful, the output of this command should be:

....
Deployed project running at http://localhost:<port>
....

Test the endpoint by opening:

....
http://127.0.0.1:<port>/starter/resource
....

You should see the following response:

....
StarterResource response
....

Undeploy the application using:

....
appsody deploy delete
....

Locate the deployment which hosts your application through the following
command:

....
$ kubectl get all
....

Copy the deployment’s URL into a browser. Congratulations! Your
application is now accessible through Knative/Kubernetes.

== Working with Appsody Collections

A collection includes everything you need to create a microservice in a
single container image, along with an enterprise-grade deployment &
integrated continuous delivery choice. Collections are developed by
application architects to match their organizational and product
requirements and work as the basis for applications created by
application developers.

A collection is defined by a combination of a stack (container images
and application templates), build/CD conventions, and deployment
best-practices.

The workshop will cover various aspects of the customization of an
existing collection, which will better prepare you for eventually
creating an entirely new collection after the workshop. The entire
process for creating a new collection is described in the
https://appsody.dev/docs/stacks/create[``Creating a Stack''] section of
the Appsody website.

=== Stacks

A https://appsody.dev/docs/stacks/stacks-overview[stack] contains at
least one pre-built container image, with the resulting runtime being
tailored to the target runtime. An application architect may to specify
different tunning parameters for a single image, such as dynamic code
reloading for development environments, or provide distinct images for
different purposes, such as an image stripped out of shell support for
production environments.

You can study the internal file structure of a stack in more detail
https://appsody.dev/docs/stacks/stack-structure[here].

==== Collection Scenario 1: Update the release of Open Liberty in the stack

The first part of the workshop used the custom
``experimental/java-microprofile-dev-mode'' stack. In this scenario, a
new version of Open Liberty is released and you, as the application
architect, want all applications based on this stack to be migrated to
the latest release in the next development and deployment cycle.

The first step is to clone the stack, which was already executed by the
prerequisite preparation steps:

....
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"

[ ! -e "${workshop_dir}/stacks" ] && \
( mkdir -p "${workshop_dir}"
  cd "${workshop_dir}"
  git clone https://github.com/gcharters/stacks )
....

In this stack, the
https://github.com/gcharters/stacks/blob/master/experimental/java-microprofile-dev-mode/image/project/Dockerfile[container
image file] specifies the usage of Maven as the build tool, and we can
see the version of Open Liberty in the ``properties'' section of the
master
https://github.com/gcharters/stacks/blob/master/experimental/java-microprofile-dev-mode/image/project/pom.xml[pom.xml
file] in that same directory:

[source,pom.xml]
----
<version.openliberty-runtime>19.0.0.7</version.openliberty-runtime>
----

You can now modify the Open Liberty version to 19.0.0.8, then use the
`+grep+` command to inspect the change:

MacOS users:

....
sed -i "" "s|19.0.0.7|19.0.0.8|g" "${workshop_dir}/stacks/experimental/java-microprofile-dev-mode/image/project/pom.xml"
....

Windows users (rom Cygwin shell):

....
sed -i "s|19.0.0.7|19.0.0.8|g" "${workshop_dir}/stacks/experimental/java-microprofile-dev-mode/image/project/pom.xml"
....

All users:

....
grep "19.0.0" "${workshop_dir}/stacks/experimental/java-microprofile-dev-mode/image/project/pom.xml"
....

With the version changed, we need to rebuild the stack before proceeding
with the stack validation steps:

(Windows users should execute the commands from a Cygwin shell)

....
cd "${workshop_dir}/stacks"
./ci/build.sh . experimental/java-microprofile-dev-mode
....

Since this local stack build was registered as an Appsody repository in
the first part of the workshop, there is no need to register it again.
It is now time to verify the changes from the perspective of the
application developer. We can go back to the original application
directory and trigger another run, which will use the updated stack:

Linux users:

....
cd "${workshop_dir}/nodejs"

appsody run
....

Windows users:

....
cd "%workshop_dir%\nodejs"

appsody run
....

As the application starts, we can see output lines indicating the newer
version of Open Liberty, which completes the scenario:

....
...

[Container] [INFO] --- liberty-maven-plugin:3.0.M1:install-server (create-server) @ starter-app ---
[Container] [INFO] CWWKM2102I: Using artifact based assembly archive : io.openliberty:openliberty-runtime:null:19.0.0.8:zip
...
....

End the application with `+Ctrl+C+`.

==== Collection Scenario 2: Custom application template

A stack contains at least one application template, which is the set of
application files placed in the application directory during the initial
creation of a project. Templates named ``default'' are used by
`+appsody init+` when the user does not specify a template name. An
application architect can create new templates to reflect different
starting points for application developers, such as a default template
for a simple stateless application or a more complex template with
starter code for connecting to a remote database.

In this scenario, we will inspect an alternative template with a
postgresql database connection endpoint, then create and test an
application starter using that template.

We first need to take a look at the alternative template, which is
located in the ``templates'' folder:

DatabaseResource.java implements a ``/database'' JAX-RS path under the
root context for the application, it relies on PaasProperties.java to
read the connection parameters. Those parameters are hardcoded for this
workshop, but a template meant for actual production environments should
read that information from a secret mounted to the pod or container.

You will also notice the addition of the postgresql JDBC driver to the
pom.xml file in the template.

Our second step is to instantiate a local PostgreSQL database. We will
use a custom docker network for both the PostgreSQL database container
and the application container, which makes it easier for the application
container to locate the database container by hostname instead of IP
address.

....
docker network create workshop_nw

docker run --rm -it --name workshop-postgres --hostname psqldb --network workshop_nw -e POSTGRES_PASSWORD=mysecretpassword -d postgres 
....

Ensure the database container is running:

....
docker ps

b66c53a3be0f        postgres                                                  "docker-entrypoint.s…"   22 seconds ago      Up 21 seconds       5432/tcp                    workshop-postgres
....

Now we can create a new application, using the template containing the
database resource:

Linux users:

....
mkdir -p "${workshop_dir}/stacktest-db"
cd "${workshop_dir}/stacktest-db"
....

Windows users:

....
mkdir -p "%workshop_dir%\stacktest-db"
cd "%workshop_dir%\stacktest-db"
....

All users:

....
appsody init workshop/java-microprofile-dev-mode psqldb

appsody run --network workshop_nw
....

Wait for the application to complete its startup cycle and verify that
the new endpoint is available, by opening the
http://localhost:9080/starter/database/ URL in a web browser, where you
should shee output like this:

....
{"client.info.ApplicationName":"PostgreSQL JDBC Driver","db.product.name":"PostgreSQL","db.product.version":"11.5 (Debian 11.5-1.pgdg90+1)","db.major.version":11,"db.minor.version":5,"db.driver.version":"42.2.6","db.jdbc.major.version":4,"db.jdbc.minor.version":2}
....

End the application with `+Ctrl+C+`, stop the workshop-postgres
container, and delete the custom network:

....
docker stop workshop-postgres
docker network rm workshop_nw
....

=== Build/CD

A collection also specifies how applications should be built and
packaged, encoding conventions about compilation aspects, packaging
tooling, unit test enforcement, static code analysis, and many others. A
full Kabanero toolchain is implemented as a sequence of steps that
happen both inside and outside the container boundaries, and this
workshop covers the steps that happen within the container boundaries,
such as compilation and packaging of binaries.

This portion of the instructions is executed directly when the developer
invokes `+appsody build+` or implicitly, when the developer invokes
`+appsody deploy+` and there are outstanding code changes since the last
build.

==== Collection Scenario 3: Add static code verification to build process

In this scenario, the entire team discussed ways of making code reviews
more efficient and agreed on ensuring minimal coding guidelines for all
applications based on that stack.

After considering multiple tools, the team agreed on using
https://maven.apache.org/plugins/maven-checkstyle-plugin/usage.html[Checkstyle]
, and the application architect can make that modification to the stack
image itself.

For simplicity we will use the default checkstyle rules, so that we just
need to add the `+checkstyle:check+` goal to the `+mvn+` invocation in
the application Dockerfile, located under:

....
${workshop_dir}/stacks/experimental/java-microprofile-dev-mode/image/project/Dockerfile
....

Change the following line from:

....
RUN mvn install -DskipTests
....

to

....
RUN mvn checkstyle:checkstyle install -DskipTests -Dcheckstyle.consoleOutput=true
....

With the change in place, we can rebuild the stack again:

Windows users should execute the commands from a Cygwin shell:

....
cd "${workshop_dir}/stacks"
./ci/build.sh . experimental/java-microprofile-dev-mode
....

And we can verify that the new code verification step is executed when
an application developer executes `+appsody build+`:

....
cd "${workshop_dir}/nodejs"
appsody build

...

>>> [Docker] Step 8/13 : RUN mvn checkstyle:check install -DskipTests
[Docker]  ---> Running in 22765b6b6301
...
[Docker] [INFO] Starting audit...
[Docker] [ERROR] /project/user-app/src/main/java/dev/appsody/starter/health/StarterReadinessCheck.java:1: Missing package-info.java file. [JavadocPackage]
...
[Docker] [ERROR] /project/user-app/src/main/java/dev/appsody/starter/StarterApplication.java:6: Missing a Javadoc comment. [JavadocType]
[Docker] Audit done.
[Docker] [INFO] There are 17 errors reported by Checkstyle 8.19 with sun_checks.xml ruleset.
...
....

==== Collection Scenario 4: Stack versioning

Appsody supports https://semver.org/[semantic versioning] during
development of stacks and applications. Notice how the checkstyle
modification from the previous scenario does not fail the build process,
but instead prints a summary of errors for the developer.

This decision was done by design, as an application architect may want
to give some time for the whole team to address the errors without
suddenly disrupting their workflow.

In this scenario, we want to show how the application architect could
release a new version of the stack that will not automatically get
picked up by developers immediately after release, so we need to
understand how Appsody tags stack images.

The initial version of the stack used in this workshop is 0.2.10, which
is listed in the output of `+appsody list+`. During compilation of the
stack, you will notice how Appsody creates 4 docker images:

....
> docker images appsody/java-microprofile-dev-mode 
REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE
appsody/java-microprofile-dev-mode   0                   ad81b68a6079        2 hours ago         1.07GB
appsody/java-microprofile-dev-mode   0.2                 ad81b68a6079        2 hours ago         1.07GB
appsody/java-microprofile-dev-mode   0.2.10              ad81b68a6079        2 hours ago         1.07GB
appsody/java-microprofile-dev-mode   latest              ad81b68a6079        2 hours ago         1.07GB
....

`+appsody init+` will always configure the application to use the
version with two digits, which is ``0.2'' in this case:

....
cd "${workshop_dir}/nodejs
cat .appsody-config.yaml

stack: appsody/java-microprofile-dev-mode:0.2
....

That means application developers will see their next call to
`+appsody run+` to automatically pick up new images tagged 0.2 when the
application architect releases any stack with a tag name starting with
``0.2.'', such as ``0.2.11''.

For this scenario, we want to modify the stack to actually break the
build in case of problems with the static code analysis and tag the
release as 0.3.1. We first replace all occurrences of 0.2.10 with 0.3.1:

Windows users should execute the commands from a Cygwin shell:

....
cd "${workshop_dir}/stacks"

 find ./experimental/java-microprofile-dev-mode -type f -exec grep -q "0.2.10" {} \; -print  | xargs -Irepl sed -i "" "s|0.2.10|0.3.1|g" repl
....

Then we inspect the changes to ensure the old version was replaced
across all affected files:

Windows users should execute the commands from a Cygwin shell:

....
find ./experimental/java-microprofile-dev-mode -type f -exec grep "0.3" {} \; -print 
version: 0.3.1
./experimental/java-microprofile-dev-mode/stack.yaml
    <version>0.3.1</version>
./experimental/java-microprofile-dev-mode/image/project/pom.xml
        <version>0.3.1</version>
./experimental/java-microprofile-dev-mode/templates/default/pom.xml
....

We can now replace the `+checkstyle:checkstyle+` goal in the `+mvn+`
invocation with `+checkstyle:check+`, which will fail the build in case
of violations of coding guidelines.

Once again, we are modifying the application Dockerfile, located under:

....
${workshop_dir}/stacks/experimental/java-microprofile-dev-mode/image/project/Dockerfile
....

Change the following line from:

....
RUN mvn checkstyle:checkstyle install -DskipTests -Dcheckstyle.consoleOutput=true
....

to

....
RUN mvn checkstyle:check install -DskipTests -Dcheckstyle.consoleOutput=true
....

With the stack version and checkstyle goal updated, we can build the
stack one last time (Windows users should execute the commands from a
Cygwin shell):

....
cd "${workshop_dir}/stacks"
./ci/build.sh . experimental/java-microprofile-dev-mode
....

Now you will notice the new stack images and how 0.2 and 0.2.10 were
left untouched.

....
docker images appsody/java-microprofile-dev-mode 

REPOSITORY                           TAG                 IMAGE ID            CREATED              SIZE
appsody/java-microprofile-dev-mode   0                   37738c47f510        About a minute ago   1.07GB
appsody/java-microprofile-dev-mode   0.3                 37738c47f510        About a minute ago   1.07GB
appsody/java-microprofile-dev-mode   0.3.1               37738c47f510        About a minute ago   1.07GB
appsody/java-microprofile-dev-mode   latest              37738c47f510        About a minute ago   1.07GB
appsody/java-microprofile-dev-mode   0.2                 ad81b68a6079        3 hours ago          1.07GB
appsody/java-microprofile-dev-mode   0.2.10              ad81b68a6079        3 hours ago          1.07GB
....

With the new stack generated, the application architect will notify
developers who are ready to make the switch to the new version about the
stack availability, at which point the application developers can modify
the appsody configuration in their application directory:

Modify the version in
``$\{workshop_dir}/nodejs/.appsody-config.yaml'' from 0.2 to 0.3

After saving the modification, you should see the following contents for
.appsody-config.yaml:

....
stack: appsody/java-microprofile-dev-mode:0.3
....

Now modify the version in ``pom.xml'' from 0.2.10 to 0.3.1.

With the new changes in place, and with the application updated to use
the latest version of the stack, requests to `+appsody build+` will fail
in case of static analysis errors:

....
> appsody build

...
[Docker] Step 8/13 : RUN mvn checkstyle:check install -DskipTests -Dcheckstyle.consoleOutput=true
...
[Docker] [ERROR] src/main/java/dev/appsody/starter/StarterApplication.java:[6] (javadoc) JavadocType: Missing a Javadoc comment.
[Docker] [INFO] ------------------------------------------------------------------------
[Docker] [INFO] BUILD FAILURE
[Docker] [INFO] ------------------------------------------------------------------------
[Docker] [INFO] Total time:  5.727 s
[Docker] [INFO] Finished at: 2019-09-06T22:37:46Z
[Docker] [INFO] ------------------------------------------------------------------------
[Docker] [ERROR] Failed to execute goal org.apache.maven.plugins:maven-checkstyle-plugin:3.1.0:check (default-cli) on project starter-app: You have 84 Checkstyle violations. -> [Help 1]
...
[Docker] [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[Docker] The command '/bin/sh -c mvn checkstyle:check install -DskipTests -Dcheckstyle.consoleOutput=true' returned a non-zero code: 1
[Error] exit status 1
....

== Further reading: Development versus production behaviour

The previous scenario showed a simple change, but Kabanero collections
can accommodate more sophisticated behaviours, where the container image
is setup with additional debugging capabilitites during development and
stripped out of those capabilities during production. This
https://github.com/appsody/stacks/pull/56[Git pull request] shows how
that type of different behaviour can be achieved, by exploring the usage
of https://appsody.dev/docs/stacks/stack-structure[different modes of a
stack]: `initialization', `rapid local development', and `build and
deploy'.
